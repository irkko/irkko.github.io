<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WELCOME</title>
    <style>
        body {
            margin: 0;
            background: black;
            color: white;
            font-family: monospace, monospace;
            display: flex;
            flex-direction: column; /* stack children vertically */
            align-items: center; /* center horizontally */
            justify-content: center; /* center vertically */
            height: 100vh;
            gap: 2rem; /* space between h1 and nav */
        }

        h1 {
            font-size: 5rem;
            font-family: 'Major Mono Display' ;
            margin: 0;
        }

        nav {
            display: flex;
            gap: 2rem; /* space between > signs */
        }

            nav a {
                position: relative;
                color: white;
                font-size: 3rem;
                text-decoration: none;
                cursor: pointer;
                user-select: none;
            }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Major+Mono+Display&display=swap" rel="stylesheet">
</head>

<body>
    <canvas id="shader-tooltip" style="position:fixed; top:0; left:0; pointer-events:none; z-index:10;"></canvas>
    <h1>WELCOME</h1>
    <nav>
        <a href="about/" data-title="About me">&gt;</a>
        <a href="games/" data-title="Games">&gt;</a>
        <a href="project-management/" data-title="Project Management">&gt;</a>
        <a href="media-production/" data-title="Media Production">&gt;</a>
        <a href="extra/" data-title="Extra">&gt;</a>
        <a href="contact/" data-title="Contact">&gt;</a>
    </nav>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
        const canvas = document.getElementById('shader-tooltip');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // transparent background

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(0, window.innerWidth, window.innerHeight, 0, 1, 10);
        camera.position.z = 5;

        // Create a canvas for text texture
        const textCanvas = document.createElement('canvas');
        const ctx = textCanvas.getContext('2d');
        textCanvas.width = 1920;
        textCanvas.height = 128;

        // Draw initial text
        function drawText(text, width = 1920, height = 128) {
            textCanvas.width = width;   // Resize canvas bounds (clears canvas!)
            textCanvas.height = height;

            ctx.font = '48px Major Mono Display'; // fixed font size
            ctx.fillStyle = 'white';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';

            ctx.fillText(text, width / 2, height / 2); // center text inside new bounds

            textTexture.needsUpdate = true;

            // Also update mesh geometry to new size to match canvas bounds
            mesh.geometry.dispose();
            mesh.geometry = new THREE.PlaneGeometry(width, height);
        }

        const textTexture = new THREE.CanvasTexture(textCanvas);
        textTexture.minFilter = THREE.LinearFilter;
        textTexture.magFilter = THREE.LinearFilter;

        const geometry = new THREE.PlaneGeometry(200, 50);

        // Simple fragment shader with a wave effect on alpha
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: textTexture },
                uTime: { value: 0 }
            },
            vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
            fragmentShader: `
          uniform sampler2D uTexture;
          uniform float uTime;
          varying vec2 vUv;
          void main() {
            vec4 color = texture2D(uTexture, vUv);
            float alphaWave = 0.5 + 0.5 * sin(uTime * 5.0 + vUv.x * 20.0);
            gl_FragColor = vec4(color.rgb, color.a * alphaWave);
          }
        `,
            transparent: true
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        mesh.visible = false;

        // Update canvas size on window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.right = window.innerWidth;
            camera.top = window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Position mesh near hovered link
        function updateMeshPosition(x, y) {
            // Convert from DOM coordinates (top-left origin) to Three.js ortho coords (bottom-left origin)
            mesh.position.x = x + 100; // 100 px right from mouse
            mesh.position.y = window.innerHeight - y - 25; // 25 px above mouse
        }

        // Handle hover on links
        const links = document.querySelectorAll('nav a');
        // Remove mousemove listener (we wonâ€™t update position on mouse move)
        links.forEach(link => {
            link.addEventListener('mouseenter', e => {
                const title = e.target.getAttribute('data-title');
                drawText(title);

                // Get bounding rect of hovered link
                const rect = e.target.getBoundingClientRect();

                // Position the mesh centered horizontally below the link, and shifted down
                // For ortho camera, Y=0 is bottom, so invert Y coord
                mesh.position.x = rect.left + rect.width / 2;
                mesh.position.y = window.innerHeight - rect.bottom - 30; // 30 px below link

                // Rotate mesh -90 degrees around Z axis
                // mesh.rotation.z = -Math.PI / 2;

                mesh.visible = true;
            });

            link.addEventListener('mouseleave', () => {
                mesh.visible = false;
            });
        });

        // Animate shader time uniform
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value = clock.getElapsedTime();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>